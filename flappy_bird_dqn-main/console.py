"""
Author: Dr Zhibin Liao
Organisation: School of Computer Science and Mathematical Sciences, University of Adelaide
Date: 03-Apr-2025
Description: This Python script is an implementation of Flappy Bird environment based on a Flappy Bird implementation
generated by ChatGPT.

The script is a part of Assignment 2 made for the course COMP SCI 3007/7059/7659 Artificial Intelligence for the year
of 2025. Public distribution of this source code is strictly forbidden.
"""
import random
import gymnasium as gym
import pygame
import os
import yaml
import math
from clock import ClockWrapper
import copy


# FlappyBird Environment (based from a Flappy Bird implementation generated by ChatGPT)
class FlappyBirdEnv(gym.Env):
    def __init__(self, config_file_path: str = None,
                 show_screen: bool = None,
                 level: int = None,
                 game_length: int = None,
                 verbose: bool = None,
                 random_seed: int = None):
        """
        The flappy bird environment. The initialisation reads a configuration file (i.e., please see config.yml) for
        defined parameters. The input arguments here can override the corresponding parameters from the configuration.
        Args:
            config_file_path: the path to the configuration file.
            show_screen: whether to show the screen.
            level: the level of the game.
            game_length: the maximum length of the game in turns of dodged pipes.
            verbose: whether to show the bird's y, velocity, and the last action taken.
            random_seed: a random seed to control the pipe randomness.
        """
        if config_file_path is None:
            raise ValueError("Config file not set: {}".format(config_file_path))
        else:
            if not os.path.exists(config_file_path):
                raise FileNotFoundError("Config file not found: {}".format(config_file_path))
            else:
                with open(config_file_path, "r") as file:
                    # Use safe_load to avoid executing arbitrary Python tags
                    config = yaml.safe_load(file)

        # load game settings from the yaml config file
        self.screen_width = config['screen_width']
        self.screen_height = config['screen_height']
        self.bird_attributes = config['bird_attributes']
        self.level = level if level is not None else config['level']
        self.pipe_attributes = config['levels'][self.level]['pipe_attributes']
        self.gravity = config['gravity']
        self.jump_strength = config['jump_strength']
        self.bird_img_obj = pygame.image.load(config['bird_img_path'])
        self.pipe_frequency = config['levels'][self.level]['pipe_attributes']['pipe_frequency']
        self.colors = config['colors']
        self.pipe_speed = config['pipe_speed']
        self.frame_rate = config['frame_rate']
        self.minimum_action_gap = config['levels'][self.level]['minimum_action_gap']
        self.action_table = config['action_table']
        self.show_screen = config['show_screen']
        self.rng = random.Random(random_seed if random_seed is not None else config['random_seed'])
        self.game_length = game_length if game_length is not None else config['levels'][self.level]['game_length']
        self.verbose = verbose if verbose is not None else config['verbose']

        # user override
        if show_screen is not None:
            self.show_screen = show_screen

        # bird parameters initialisation
        self.bird_x = self.bird_attributes['x']
        self.bird_y = self.bird_attributes['y']
        self.bird_velocity = 0

        # game parameters
        self.done = False
        self.done_type = None

        # game scores
        self.score = 0
        self.mileage = 0
        self.last_pipe_time = 0
        self.clock = ClockWrapper(show_screen=self.show_screen, frame_rate=self.frame_rate)
        self.start_time = 0

        # pipes are stored here
        self.pipes = []

        # screen/on-screen parameters
        self.screen = None
        self.font = None
        self.bird_img = None

        # reversing the action table key and value for convince
        self.reverse_action_table = {v: k for k, v in self.action_table.items()}

    """
    This is useful to regain the control of random sequence. Most likely you don't need it unless you want to replay
    the best score episode provided you've recorded the random seed that initialised the environment.
    """
    def reset_random_seed(self, random_seed: int = None):
        self.rng = random.Random(random_seed)

    def reset(self, **kwargs):
        super(FlappyBirdEnv, self).reset(**kwargs)
        self.pipes = []
        self.bird_x = self.bird_attributes['x']
        self.bird_y = self.bird_attributes['y']
        self.bird_velocity = 0
        self.done = False
        self.done_type = None
        self.score = 0
        self.mileage = 0
        self.last_pipe_time = 0
        self.start_time = 0
        self.clock = ClockWrapper(show_screen=self.show_screen, frame_rate=self.frame_rate)
        return self.get_state()

    def get_state(self):
        state = {'bird_x': self.bird_x,
                 'bird_y': self.bird_y,
                 'bird_width': self.bird_attributes['width'],
                 'bird_height': self.bird_attributes['height'],
                 'bird_velocity': self.bird_velocity,
                 'pipes': self.pipes,
                 'pipe_attributes': self.pipe_attributes,
                 'screen_width': self.screen_width,
                 'screen_height': self.screen_height,
                 'score': self.score,
                 'mileage': self.mileage,
                 'done': self.done,
                 'done_type': self.done_type
                 }
        return copy.deepcopy(state)  # deep copy to ensure the game won't be modified by the agent ;)

    def replay_game(self):
        """
        This function makes a simple replay inference for the human agent
        Returns:
            A boolean indicator whether the user wants to replay the game.
        """
        if self.show_screen:
            pygame.draw.rect(self.screen, (0, 0, 0), (0, 0, self.screen_width, self.screen_height))
            restart_text = self.font.render(f"Press R to restart", True, self.colors['score'])
            w, h = restart_text.get_size()
            self.screen.blit(restart_text, ((self.screen_width - w) / 2, (self.screen_height - h) / 2))
            pygame.display.update()
            while True:
                # Refresh screen
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        return False
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_r:
                            return True
        else:
            return False

    def play(self, player=None):
        """
        The main function that handles the game
        Args:
            player: an agent instance which implements the choose_action(...) and receive_after_action_observation(...)
                    functions
        Returns:
            None
        """
        self.show_screen = player.show_screen
        self.reset()

        if self.show_screen:
            print('Game Start')
            pygame.init()
            self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
            pygame.display.set_caption("Flappy Bird")

            # Load assets
            # Use a small bird image (or replace with a pygame.Rect)
            self.bird_img = pygame.transform.scale(self.bird_img_obj, (self.bird_attributes['width'], self.bird_attributes['height']))

            self.font = pygame.font.Font(None, 30)
            self.bird_font = pygame.font.Font(None, 24)

        self.last_pipe_time = self.clock.current_time()
        self.start_time = self.last_pipe_time

        while not self.done:  # I'm not done yet!
            if self.show_screen:
                self.screen.fill(self.colors['background'])

            current_state = self.get_state()

            # Handle events
            action = player.choose_action(state=current_state, action_table=self.get_action_table())
            if action == self.action_table['quit_game']:
                self.done = True
            elif action == self.action_table['jump']:
                self.bird_velocity = self.jump_strength
            elif action == self.action_table['do_nothing']:
                pass
            else:
                raise ValueError('Invalid action code: {}'.format(action))

            for i in range(self.minimum_action_gap):
                if i == 0:
                    self.step(action)
                else:
                    self.step(self.action_table['do_nothing'])

            if self.score >= self.game_length:
                self.done = True
                self.done_type = 'well_done'

            state_after_action = self.get_state()

            player.receive_after_action_observation(state_after_action, action_table=self.get_action_table())

    def step(self, action):
        """
        Execute the game for one step
        Args:
            action: the action to take in the current step

        Returns:
            None
        """
        if self.show_screen:
            self.screen.fill(self.colors['background'])

        current_time = self.clock.current_time()

        # Apply gravity
        self.bird_velocity += self.gravity
        self.bird_y += self.bird_velocity

        # Pipe generation
        if current_time - self.last_pipe_time > self.pipe_frequency:
            if self.pipe_attributes['formation'] == 'random':
                window_y_top = self.rng.randint(self.pipe_attributes['window_y_mean'] - self.pipe_attributes['window_y_offset'],
                                                self.pipe_attributes['window_y_mean'] + self.pipe_attributes['window_y_offset'])
            elif self.pipe_attributes['formation'] == 'sine':
                normalised_position = math.sin(((current_time - self.start_time)/self.pipe_frequency - 1.) * math.pi / 4)
                window_y_top = normalised_position * self.pipe_attributes['window_y_offset'] + self.pipe_attributes['window_y_mean']
            else:
                raise ValueError('Invalid pipe formation argument: {}'.format(self.pipe_attributes['formation']))
            window_y_bottom = window_y_top + self.pipe_attributes['gap']
            self.pipes.append({"x": self.screen_width, "top": window_y_top,
                               "bottom": window_y_bottom, "width": self.pipe_attributes['width']})
            self.last_pipe_time = current_time

        # Move pipes
        for pipe in self.pipes:
            pipe["x"] -= self.pipe_speed

        # add mileage
        self.mileage += self.pipe_speed

        # Remove off-screen pipes
        num_pipes = len(self.pipes)
        self.pipes = [pipe for pipe in self.pipes if pipe["x"] + self.pipe_attributes['width'] > 0]
        num_pipes_removed = num_pipes - len(self.pipes)
        self.score += num_pipes_removed

        # Collision detection
        for pipe in self.pipes:
            if self.bird_x + self.bird_attributes['width'] > pipe["x"] and self.bird_x < pipe["x"] + \
                    self.pipe_attributes['width']:
                if self.bird_y < pipe["top"] or self.bird_y + self.bird_attributes['height'] > pipe["bottom"]:
                    self.done_type = 'hit_pipe'
                    self.done = True  # Collision detected
                    break

        # Check if bird falls out of the screen
        if self.bird_y > self.screen_height or self.bird_y < 0:
            self.done_type = 'offscreen'
            self.done = True

        if not self.done:
            self.done_type = 'not_done'

        # Draw pipes
        if self.show_screen:
            for pipe in self.pipes:
                # Top pipe
                pygame.draw.rect(self.screen, self.colors['pipe'],
                                 (pipe["x"], 0, self.pipe_attributes['width'], pipe["top"]))
                # Bottom pipe
                pygame.draw.rect(self.screen, self.colors['pipe'],
                                 (pipe["x"], pipe["bottom"], self.pipe_attributes['width'],
                                  self.screen_height - pipe["bottom"]))

            # Draw bird
            self.screen.blit(self.bird_img, (self.bird_x, self.bird_y))

            # Draw score
            score_text = self.font.render(f"Mileage: {self.mileage} Score: {self.score}", True, self.colors['score'])
            self.screen.blit(score_text, (10, 10))
            if self.verbose:
                bird_text = self.bird_font.render(
                    f"(H: {int(self.bird_y):03d}, V: {int(self.bird_velocity):02d}, A: {self.reverse_action_table[action]})",
                    True, self.colors['score'])
                self.screen.blit(bird_text, (self.bird_x, self.bird_y - 24))

            # Refresh screen
            pygame.display.update()
            pygame.event.pump()

        self.clock.tick()

    def get_action_table(self) -> dict:
        """
        Get the action table
        Returns:
            The action table of the game in a dictionary structure
        """
        return copy.deepcopy(self.action_table)  # deep copy to ensure the game won't be modified by the agent ;)

